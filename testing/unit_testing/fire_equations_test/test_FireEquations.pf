module test_FireEquations
  !
  ! DESCRIPTION:
  !		Test the SPITFIRE-related equations - tests all methods in SFEquationsMod
  !
  use FatesConstantsMod,   only : r8 => fates_r8
  use FatesConstantsMod,   only : nearzero
  use SFEquationsMod
  use funit

  implicit none

  @TestCase
  type, extends(TestCase) :: TestFireEquations
  end type TestFireEquations

  real(r8), parameter :: tol = 1.e-7_r8

  contains 

    @Test 
    subroutine OptimumPackingRatio_ZeroInput_ReturnsZero(this)
      ! test that when SAV is zero or very close to zero, OptimumPackingRatio returns 0.0
      class(TestFireEquations), intent(inout) :: this ! test object
      real(r8)                                :: beta ! optimum packing ratio returned
    
      ! first test 0.0
      beta = OptimumPackingRatio(0.0_r8)
      @assertEqual(beta, 0.0_r8)
      
      ! now test close to zero
      beta = OptimumPackingRatio(1.0e-31_r8)
      @assertEqual(beta, 0.0_r8)
      
    end subroutine OptimumPackingRatio_ZeroInput_ReturnsZero
    
    @Test 
    subroutine OptimumPackingRatio_ReturnsReasonableValues(this)
      ! test that when SAV is some reasonable value, OptimumPackingRatio is correclty output
      class(TestFireEquations), intent(inout) :: this ! test object
      real(r8)                                :: beta ! optimum packing ratio returned
    
      ! test 1.0, 10.0, 100.0, 1000.0
      beta = OptimumPackingRatio(1.0_r8)
      @assertEqual(beta, 0.200395_r8, tolerance=tol)
      
      beta = OptimumPackingRatio(10.0_r8)
      @assertEqual(beta, 0.03040793_r8, tolerance=tol)
      
      beta = OptimumPackingRatio(100.0_r8)
      @assertEqual(beta, 0.004614099_r8, tolerance=tol)
      
      beta = OptimumPackingRatio(1000.0_r8)
      @assertEqual(beta, 0.0007001432_r8, tolerance=tol)
      
    end subroutine OptimumPackingRatio_ReturnsReasonableValues
    
    @Test 
    subroutine OptimumPackingRatio_VerySmall_ReturnsReasonableValues(this)
      ! test that when SAV is very small (but not zero), the function returns something larger than zero
      class(TestFireEquations), intent(inout) :: this ! test object
      real(r8)                                :: beta ! optimum packing ratio returned
    
      ! test a small number as well as nearzero
      beta = OptimumPackingRatio(1.0e-6_r8)
      @assertGreaterThan(beta, 0.0_r8)
      
      beta = OptimumPackingRatio(nearzero)
      @assertGreaterThan(beta, 0.0_r8)
      
    end subroutine OptimumPackingRatio_VerySmall_ReturnsReasonableValues
    
    @Test 
    subroutine MaximumReactionVelocity_ZeroInput_ReturnsZero(this)
      ! test that when SAV is zero or very close to zero, MaximumReactionVelocity returns 0.0
      class(TestFireEquations), intent(inout) :: this ! test object
      real(r8)                                :: vel  ! maximum reaction velocity returned
    
      ! first test 0.0
      vel = MaximumReactionVelocity(0.0_r8)
      @assertEqual(vel, 0.0_r8)
      
      ! now test close to zero
      vel = MaximumReactionVelocity(1.0e-31_r8)
      @assertEqual(vel, 0.0_r8)
      
    end subroutine MaximumReactionVelocity_ZeroInput_ReturnsZero
    
    @Test 
    subroutine MaximumReactionVelocity_DecreasesAsSAVIncreases(this)
      ! test that MaximumReactionVelocity output decreases as SAV input increases
      class(TestFireEquations), intent(inout) :: this    ! test object
      real(r8)                                :: vels(5) ! maximum reaction velocity returned
      integer                                 :: i       ! looping index
      ! hard-coded sav values
      real(r8), parameter :: sav_vals(5) = [10.0_r8, 50.0_r8, 100.0_r8, 500.0_r8, 1000.0_r8]
    
      do i = 1, size(sav_vals)
        vels(i) = MaximumReactionVelocity(sav_vals(i))
      end do
      
      ! check that function outputs decrease as SAV increases
      do i = 1, size(sav_vals) - 1
        @assertLessThan(vels(i), vels(i+1), tolerance=tol)
      end do
    
    end subroutine MaximumReactionVelocity_DecreasesAsSAVIncreases
    
    @Test 
    subroutine MaximumReactionVelocity_VerySmall_ReturnsNonZero(this)
      ! test that when SAV is very small (but not zero), the function returns something larger than zero
      class(TestFireEquations), intent(inout) :: this ! test object
      real(r8)                                :: vel  ! maximum reaction velocity returned
    
      ! test a small number as well as nearzero
      vel = MaximumReactionVelocity(1.0e-6_r8)
      @assertGreaterThan(vel, 0.0_r8)
      
      vel = MaximumReactionVelocity(nearzero)
      @assertGreaterThan(vel, 0.0_r8)
      
    end subroutine MaximumReactionVelocity_VerySmall_ReturnsNonZero
    
    @Test 
    subroutine OptimumReactionVelocity_BetaRatioZero_ReturnsZero(this)
      ! test that when beta ratio is zero, the function returns zero
      class(TestFireEquations), intent(inout) :: this                       ! test object
      real(r8)                                :: vel                        ! optimum reaction velocity returned
      real(r8), parameter                     :: max_reaction_vel = 10.0_r8 ! default for maximum reaction velocity
      real(r8), parameter                     :: sav = 50.0_r8              ! default for SAV
    
      vel = OptimumReactionVelocity(max_reaction_vel, sav, 0.0_r8)
      @assertEqual(vel, 0.0_r8)
      
    end subroutine OptimumReactionVelocity_BetaRatioZero_ReturnsZero
    
    @Test 
    subroutine OptimumReactionVelocity_BetaRatioOne_ReturnsMaxReactionVel(this)
      ! test that when beta ratio is 1.0, the function returns maximum reaction velocity
      class(TestFireEquations), intent(inout) :: this                       ! test object
      real(r8)                                :: vel                        ! optimum reaction velocity returned
      real(r8), parameter                     :: max_reaction_vel = 10.0_r8 ! default for maximum reaction velocity
      real(r8), parameter                     :: sav = 50.0_r8              ! default for SAV
    
      vel = OptimumReactionVelocity(max_reaction_vel, sav, 1.0_r8)
      @assertEqual(vel, max_reaction_vel)
      
    end subroutine OptimumReactionVelocity_BetaRatioOne_ReturnsMaxReactionVel
    
    @Test 
    subroutine OptimumReactionVelocity_ReasonableInputs_ReturnsNonZero(this)
      ! test that OptimumReactionVelocity produces reasonable output with reasonable input values (i.e. non zero)
      class(TestFireEquations), intent(inout) :: this                       ! test object
      real(r8)                                :: vel                        ! optimum reaction velocity returned
      integer                                 :: i, j                       ! looping indices
      real(r8), parameter                     :: max_reaction_vel = 10.0_r8 ! default for maximum reaction velocity
      ! hard-coded sav and beta values
      real(r8), parameter :: sav_vals(3) = [10.0_r8, 50.0_r8, 100.0_r8]
      real(r8), parameter :: beta_vals(3) = [0.25_r8, 0.5_r8, 0.75_r8]
    
      do i = 1, size(sav_vals)
        do j = 1, size(beta_vals)
          vel = OptimumReactionVelocity(max_reaction_vel, sav_vals(i), beta_vals(j))
          @assertGreaterThan(vel, 0.0_r8, tolerance=tol)
        end do
      end do
      
    end subroutine OptimumReactionVelocity_ReasonableInputs_ReturnsNonZero
    
    @Test 
    subroutine OptimumReactionVelocity_DecreasesAsSAVIncreases(this)
      ! test that OptimumReactionVelocity output decreases as SAV input increases
      class(TestFireEquations), intent(inout) :: this                       ! test object
      real(r8)                                :: vels(7)                    ! maximum reaction velocity returned
      integer                                 :: i                          ! looping index
      real(r8), parameter                     :: max_reaction_vel = 10.0_r8 ! default for maximum reaction velocity
      real(r8), parameter                     :: beta = 0.5_r8              ! default for beta
      ! hard-coded sav values
      real(r8), parameter :: sav_vals(7) = [0.1_r8, 1.0_r8, 10.0_r8, 50.0_r8, 100.0_r8, 500.0_r8, 1000.0_r8]
    
      do i = 1, size(sav_vals)
        vels(i) = OptimumReactionVelocity(max_reaction_vel, sav_vals(i), beta)
      end do
      
      ! check that function outputs decrease as SAV increases
      do i = 1, size(sav_vals) - 1
        @assertLessThan(vels(i), vels(i+1), tolerance=tol)
      end do
    
    end subroutine OptimumReactionVelocity_DecreasesAsSAVIncreases
    
    @Test 
    subroutine OptimumReactionVelocity_ScalesWithMaxReactionVel(this)
      ! test that OptimumReactionVelocity scales correctly with maximum reaction velocity
      class(TestFireEquations), intent(inout) :: this                        ! test object
      real(r8)                                :: vel1                        ! result for max reaction vel 1
      real(r8)                                :: vel2                        ! result for max reaction vel 2
      real(r8)                                :: ratio                       ! ratio between vel2 and vel1
      real(r8), parameter                     :: max_reaction_vel1 = 5.0_r8  ! default 1 for maximum reaction velocity
      real(r8), parameter                     :: max_reaction_vel2 = 10.0_r8 ! default 2 for maximum reaction velocity
      real(r8), parameter                     :: sav = 50.0_r8               ! default for SAV
      real(r8), parameter                     :: beta = 0.6_r8               ! default for beta

      vel1 = OptimumReactionVelocity(max_reaction_vel1, sav, beta)
      vel2 = OptimumReactionVelocity(max_reaction_vel2, sav, beta)
      ratio = vel2/vel1
      
      @assertEqual(ratio, 2.0_r8 , tolerance=tol)
      
    end subroutine OptimumReactionVelocity_ScalesWithMaxReactionVel
    
    @Test 
    subroutine MoistureCoefficient_ZeroMoisture_ReturnsOne(this)
      ! test that when moisture is zero, the function returns one
      class(TestFireEquations), intent(inout) :: this         ! test object
      real(r8)                                :: coeff        ! result 
      real(r8),                 parameter     :: MEF = 0.3_r8 ! default value for MEF

      coeff = MoistureCoefficient(0.0_r8, MEF)
      @assertEqual(coeff, 1.0_r8)
      
    end subroutine MoistureCoefficient_ZeroMoisture_ReturnsOne
    
    @Test 
    subroutine MoistureCoefficient_MoistureExceedsMEF_ReturnsZero(this)
      ! test that when moisture exceeds MEF, the function resturns zero
      class(TestFireEquations), intent(inout) :: this         ! test object
      real(r8)                                :: coeff        ! result 
      real(r8),                 parameter     :: MEF = 0.3_r8 ! default value for MEF

      coeff = MoistureCoefficient(0.4_r8, MEF)
      @assertEqual(coeff, 0.0_r8)
      
    end subroutine MoistureCoefficient_MoistureExceedsMEF_ReturnsZero
    
    @Test 
    subroutine MoistureCoefficient_DecreasesWithIncreasingMoisture(this)
      ! test that when moisture increases, the coefficient decreases
      class(TestFireEquations), intent(inout) :: this         ! test object
      real(r8)                                :: coeffs(6)    ! result 
      integer                                 :: i            ! looping index
      real(r8),                 parameter     :: MEF = 0.6_r8 ! default value for MEF
      ! hard-coded moisture values
      real(r8), parameter :: moist(6) = [0.1_r8, 0.2_r8, 0.3_r8, 0.4_r8, 0.5_r8, 0.55_r8]
     
      do i = 1, size(moist)
        coeffs(i) = MoistureCoefficient(moist(i), MEF)
      end do
    
      do i = 1, size(moist) - 1
        
        ! check that function outputs decrease as moisture increases
        @assertLessThan(moist(i), moist(i+1), tolerance=tol)
        
        ! also make sure value is between 0.0 and 1.0
        @assertLessThan(moist(i), 1.0_r8, tolerance=tol)
        @assertGreaterThan(moist(i), 0.0_r8, tolerance=tol)
      end do
    
    end subroutine MoistureCoefficient_DecreasesWithIncreasingMoisture
    
    @Test 
    subroutine MoistureCoefficient_MEFZero_ReturnsZero(this)
      ! test that when MEF == zero, function returns zero - this is an edge case
      class(TestFireEquations), intent(inout) :: this           ! test object
      real(r8)                                :: coeff          ! result 
      real(r8),                 parameter     :: moist = 0.3_r8 ! default value for moisture

      coeff = MoistureCoefficient(moist, 0.0_r8)
      @assertEqual(coeff, 0.0_r8)
      
    end subroutine MoistureCoefficient_MEFZero_ReturnsZero
    
end module test_FireEquations
